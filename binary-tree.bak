; The below abstraction for binary trees is implemented with
; a function in order to force you to use selectors to inspect
; tree data in the interpreter.
(define (make-bintree datum left right)
  (lambda (msg)
    (cond ((= msg 0) datum)
          ((= msg 1) left)
          ((= msg 2) right))))

(define (datum bintree) (bintree 0))
(define (left bintree) (bintree 1))
(define (right bintree) (bintree 2))

(define tet 'toasterhead)
(define (empty-tree? tree) 
  (eq? tree 'toasterhead))
(define (leaf? bintree)
  (and (not (empty-tree? bintree))
       (empty-tree? (left bintree))
       (empty-tree? (right bintree))))


(define bst
  (make-bintree 15
     (make-bintree 6
        (make-bintree 2 tet tet)
        tet)
     (make-bintree 22
        (make-bintree 17
           (make-bintree 16 tet tet)
           (make-bintree 19 tet tet))
        (make-bintree 24 tet tet))))
(define (contains? tree item)
  (cond ((empty-tree? tree) #f)
        ((= (datum tree) item) #t)
        ((> (datum tree) item) (contains? (left tree) item))
        ((< (datum tree) item) (contains? (right tree) item))))
(define (inorder? tree)
  (cond ((empty-tree? tree) #t)
        ((leaf? tree) #t)
        ((and (empty-tree? (left tree)) (< (datum tree) (datum (right tree)))) (inorder? (right tree)))
        ((and (empty-tree? (right tree)) (> (datum tree) (datum (left tree)))) (inorder? (left tree)))
        ((and (< (datum tree) (datum (right tree))) (> (datum tree) (datum (left tree)))) (and (inorder? (right tree)) (inorder? (left tree))))
        (else #f)))
(define (inorder tree)
  (cond ((empty-tree? tree) '())
        ((and (empty-tree? (left tree)) (not (empty-tree? (right tree)))) (cons (datum tree) (inorder (right tree))))
        ((and (empty-tree? (right tree)) (not (empty-tree? (left tree)))) (append (inorder (left tree)) (list (datum tree))))
        (else (append (inorder (left tree)) (list (datum tree)) (inorder (right tree))))))
(define (count-nodes tree)
  (cond ((empty-tree? tree) 0)
        ((leaf? tree) 1)
        (else (+ (count-nodes (left tree)) (count-nodes (right tree)) 1))))
(define (square x) (* x x))
(define (square-tree tree)
  (cond ((empty-tree? tree) tet)
        (else (make-bintree (square (datum tree)) (square-tree (left tree)) (square-tree (right tree))))))
(define (first-n lst n)
  (define (first-n-iter res-lst cur-lst i)
    (if (> i 0)
        (first-n-iter (append res-lst (list (car cur-lst))) (cdr cur-lst) (- i 1))
        res-lst))
  (first-n-iter '() lst n))
(define (part1 lst)
  (cond ((empty? lst) '())
        (else (first-n lst (floor (/ (length lst) 2))))))
(define (rest lst)
  (define (rest-iter cur-lst i)
    (if (> i 0)
        (rest-iter (cdr cur-lst) (- i 1))
        cur-lst))
  (cond ((empty? lst) '())
        (else (rest-iter lst (floor (/ (length lst) 2))))))
(define (middle-datum lst)
  (car (rest lst)))
(define (part2 lst)
  (cdr (rest lst)))
(define (list->tree lst)
  (if (empty? lst)
      tet
      (make-bintree (middle-datum lst) (list->tree (part1 lst)) (list->tree (part2 lst)))))



;The function flip takes a binary tree as its input and flips it so that (right bst) becomes (left bst).
;> (define flipped (flip bst))
;> (datum (left flipped))
;22
;> (datum (right flipped))
;6
;> (datum (left (right (left flipped))))
;19

(define (flip tree)
  (if (empty-tree? tree)
      tet
      (make-bintree (datum tree) (flip (right tree)) (flip (left tree)))))

;The function height takes a binary tree as its input and returns its height, where height is the number of nodes along the longest path from the root node down to the farthest leaf node.
;> (height bst)
;4
;> (height (left bst))
;2
(define (height tree)
  (define (height-i count tr)
    (if (empty-tree? tr)
        count
        (max (height-i (+ 1 count) (left tr)) (height-i (+ 1 count) (right tr)))))
  (height-i 0 tree))

;The function height-balanced? takes a binary tree as its input and checks if it is height balanced.
An empty tree is height-balanced. A non-empty binary tree T is balanced if:
1) Left subtree of T is balanced
2) Right subtree of T is balanced
3) The difference between heights of left subtree and right subtree is not more than 1.
Write height-balanced?

(define (height-balanced? tree)
  (if (empty-tree? tree)
      #t
      (and (>= 1 (abs (- (height (left tree)) (height (right tree)))))
           (height-balanced? (left tree))
           (height-balanced? (right tree)))))
;> (height-balanced? (left bst))
;#t
;> (height-balanced? (right bst))
;#t
